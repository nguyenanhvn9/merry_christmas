<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Christmas Tree - WebGL Performance</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #050505;
            font-family: 'Arial', sans-serif;
        }
        canvas {
            display: block;
        }
        #message {
            position: absolute;
            bottom: 10%;
            width: 100%;
            text-align: center;
            color: rgba(255, 255, 255, 0.9);
            font-size: 3rem;
            font-weight: 300;
            font-family: 'Brush Script MT', cursive;
            text-shadow: 0 0 10px #ff69b4, 0 0 20px #ff69b4;
            pointer-events: none;
            animation: glow 2s infinite alternate;
            z-index: 10;
        }
        #musicControl {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            width: 60px;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 10;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }
        #musicControl:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 105, 180, 0.8);
            transform: scale(1.1);
            box-shadow: 0 0 20px rgba(255, 105, 180, 0.6);
        }
        #musicControl svg {
            width: 30px;
            height: 30px;
            fill: white;
        }
        #youtubePlayer {
            position: absolute;
            top: -9999px;
            left: -9999px;
            pointer-events: none;
        }
        #startOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            cursor: pointer;
            transition: opacity 0.5s ease;
        }
        #startOverlay.hidden {
            opacity: 0;
            pointer-events: none;
        }
        #startButton {
            background: linear-gradient(135deg, #ff69b4, #ff1493);
            color: white;
            border: none;
            padding: 20px 50px;
            font-size: 1.8rem;
            font-weight: bold;
            border-radius: 50px;
            cursor: pointer;
            box-shadow: 0 0 30px rgba(255, 105, 180, 0.6);
            transition: all 0.3s ease;
            font-family: 'Arial', sans-serif;
        }
        #startButton:hover {
            transform: scale(1.1);
            box-shadow: 0 0 50px rgba(255, 105, 180, 0.9);
        }
        #startText {
            color: white;
            font-size: 1.5rem;
            margin-bottom: 30px;
            text-align: center;
            font-family: 'Brush Script MT', cursive;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }
        @keyframes glow {
            0% { 
                opacity: 0.8; 
                text-shadow: 0 0 10px #ff69b4, 0 0 20px #ff69b4;
                transform: scale(1);
            }
            50% { 
                opacity: 1; 
                text-shadow: 0 0 30px #ff1493, 0 0 50px #ff69b4, 0 0 10px white;
                transform: scale(1.05);
            }
            100% { 
                opacity: 0.8; 
                text-shadow: 0 0 10px #ff69b4, 0 0 20px #ff69b4;
                transform: scale(1);
            }
        }
    </style>
</head>
<body>

    <!-- Start Overlay -->
    <div id="startOverlay">
        <div id="startText">üéÑ Gi√°ng sinh an l√†nh üéÑ</div>
        <button id="startButton">üéµ B·∫Øt ƒê·∫ßu üéÖ</button>
    </div>

    <div id="message">Merry Christmas</div>
    <div id="container"></div>
    
    <!-- Music Control Button -->
    <div id="musicControl" title="B·∫≠t/T·∫Øt nh·∫°c">
        <svg id="playIcon" viewBox="0 0 24 24">
            <path d="M8 5v14l11-7z"/>
        </svg>
        <svg id="pauseIcon" viewBox="0 0 24 24" style="display:none;">
            <path d="M6 4h4v16H6V4zm8 0h4v16h-4V4z"/>
        </svg>
    </div>
    
    <!-- Audio Player -->
    <audio id="audioPlayer" loop style="display:none;">
        <source src="song.mp3" type="audio/mpeg">
    </audio>

    <!-- Three.js CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <script>
        // ========== MUSIC PLAYER ==========
        let audioPlayer = document.getElementById('audioPlayer');
        let isPlaying = false;
        const playIcon = document.getElementById('playIcon');
        const pauseIcon = document.getElementById('pauseIcon');
        const musicControl = document.getElementById('musicControl');
        const startOverlay = document.getElementById('startOverlay');
        const startButton = document.getElementById('startButton');

        // X·ª≠ l√Ω click v√†o overlay ho·∫∑c n√∫t start
        function startExperience() {
            console.log('üéÑ Starting Christmas experience...');
            startOverlay.classList.add('hidden');
            
            // T·ª± ƒë·ªông ph√°t nh·∫°c t·ª´ file song.mp3
            audioPlayer.volume = 0.5;
            audioPlayer.play()
                .then(() => {
                    console.log('üéµ Music playing from song.mp3!');
                    isPlaying = true;
                    updateMusicButton();
                })
                .catch(err => {
                    console.error('‚ùå Audio play error:', err);
                    console.log('üí° H√£y ƒë·∫£m b·∫£o file song.mp3 n·∫±m c√πng th∆∞ m·ª•c v·ªõi file HTML n√†y');
                });
            
            setTimeout(() => {
                startOverlay.style.display = 'none';
            }, 500);
        }

        startButton.addEventListener('click', startExperience);
        startOverlay.addEventListener('click', (e) => {
            if (e.target === startOverlay) {
                startExperience();
            }
        });

        function toggleMusic() {
            console.log('Toggle music. Current state:', isPlaying);
            
            if (isPlaying) {
                audioPlayer.pause();
                isPlaying = false;
            } else {
                audioPlayer.play()
                    .then(() => {
                        isPlaying = true;
                    })
                    .catch(err => {
                        console.error('‚ùå Cannot play audio:', err);
                    });
            }
            updateMusicButton();
        }

        function updateMusicButton() {
            if (isPlaying) {
                playIcon.style.display = 'none';
                pauseIcon.style.display = 'block';
            } else {
                playIcon.style.display = 'block';
                pauseIcon.style.display = 'none';
            }
        }

        // Event listener cho n√∫t nh·∫°c
        musicControl.addEventListener('click', toggleMusic);

        // ========== THREE.JS MAIN CODE ==========
    </script>
    
    <script>
        // ========== THREE.JS SETUP ==========
        let scene, camera, renderer;
        let treeGroup, ledGroup, snowGroup, magicGroup, santaSleighSprite, sleighTrailParticles;
        
        // C·∫•u h√¨nh
        const TREE_HEIGHT = 400;
        const BASE_RADIUS = 180;
        const ROTATION_SPEED = 0.005;

        // M√†u s·∫Øc
        const COLORS = [
            0xffb7b2, 0xff9cee, 0xff69b4, 0xe056fd, 
            0xffd700, 0x00ffff, 0xffffff
        ];

        const LED_COLORS = [
            0xff0000, 0x00ff00, 0x0000ff, 0xffff00, 
            0xff00ff, 0x00ffff, 0xffa500
        ];

        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x050505);
            scene.fog = new THREE.Fog(0x050505, 400, 1500);

            // Camera
            camera = new THREE.PerspectiveCamera(
                50, 
                window.innerWidth / window.innerHeight, 
                1, 
                2000
            );
            camera.position.set(0, 0, 600);
            camera.lookAt(0, 0, 0);

            // Renderer v·ªõi performance cao
            renderer = new THREE.WebGLRenderer({ 
                antialias: true,
                alpha: true,
                powerPreference: "high-performance"
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.getElementById('container').appendChild(renderer.domElement);

            // √Ånh s√°ng
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
            scene.add(ambientLight);

            const pointLight1 = new THREE.PointLight(0xff69b4, 1.5, 1000);
            pointLight1.position.set(200, 0, 200);
            scene.add(pointLight1);

            const pointLight2 = new THREE.PointLight(0x00ffff, 1.5, 1000);
            pointLight2.position.set(-200, 0, 200);
            scene.add(pointLight2);

            const pointLight3 = new THREE.PointLight(0xffd700, 1, 800);
            pointLight3.position.set(0, -200, 100);
            scene.add(pointLight3);

            // T·∫°o c√°c nh√≥m
            treeGroup = new THREE.Group();
            ledGroup = new THREE.Group();
            snowGroup = new THREE.Group();
            magicGroup = new THREE.Group();
            
            scene.add(treeGroup);
            scene.add(ledGroup);
            scene.add(snowGroup);
            scene.add(magicGroup);

            // T·∫°o c√¢y v√† hi·ªáu ·ª©ng
            createTree();
            createLEDs();
            createRibbons();
            createHeartAtTop();
            createStarAtTop();
            createGiftBoxes();
            createSnowFloor();
            createSnowfall();
            createMagicParticles();
            createSantaSleighImage();

            // Resize handler
            window.addEventListener('resize', onWindowResize);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // ========== T·∫†O C√ÇY TH√îNG ==========
        function createTree() {
            const positions = [];
            const colors = [];
            const sizes = [];

            // Th√¢n c√¢y ch√≠nh - tƒÉng l√™n 4000 particles nh∆∞ng v·∫´n m∆∞·ª£t nh·ªù GPU
            const particleCount = 4000;
            for (let i = 0; i < particleCount; i++) {
                const t = i / particleCount;
                const angle = t * Math.PI * 2 * 20;
                const radius = BASE_RADIUS * (1 - t);
                
                const x = Math.cos(angle) * radius;
                const z = Math.sin(angle) * radius;
                const y = t * -TREE_HEIGHT + TREE_HEIGHT / 2;
                
                positions.push(x, y, z);
                
                const color = new THREE.Color(COLORS[Math.floor(Math.random() * COLORS.length)]);
                colors.push(color.r, color.g, color.b);
                
                sizes.push(2 + Math.random() * 4);

                // Th√™m h·∫°t b√™n trong
                if (Math.random() < 0.35) {
                    const innerR = radius * Math.random() * 0.85;
                    const innerX = Math.cos(angle) * innerR;
                    const innerZ = Math.sin(angle) * innerR;
                    
                    positions.push(innerX, y, innerZ);
                    colors.push(color.r, color.g, color.b);
                    sizes.push(1.5 + Math.random() * 2.5);
                }
            }

            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));

            const material = new THREE.PointsMaterial({
                size: 2.5,
                vertexColors: true,
                transparent: true,
                opacity: 0.85,
                sizeAttenuation: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });

            const points = new THREE.Points(geometry, material);
            treeGroup.add(points);
        }

        // ========== ƒê√àN LED NH·∫§P NH√ÅY ==========
        function createLEDs() {
            const ledCount = 120;
            const leds = [];

            for (let i = 0; i < ledCount; i++) {
                const t = i / ledCount;
                const angle = t * Math.PI * 2 * 15;
                const radius = BASE_RADIUS * (1 - t) * 0.9;
                
                const x = Math.cos(angle) * radius;
                const z = Math.sin(angle) * radius;
                const y = t * -TREE_HEIGHT + TREE_HEIGHT / 2;

                const geometry = new THREE.SphereGeometry(3, 12, 12);
                const material = new THREE.MeshPhongMaterial({
                    color: LED_COLORS[Math.floor(Math.random() * LED_COLORS.length)],
                    emissive: LED_COLORS[Math.floor(Math.random() * LED_COLORS.length)],
                    emissiveIntensity: 0.8,
                    transparent: true,
                    opacity: 1
                });
                
                const led = new THREE.Mesh(geometry, material);
                led.position.set(x, y, z);
                led.userData.blinkPhase = Math.random() * Math.PI * 2;
                led.userData.blinkSpeed = 0.04 + Math.random() * 0.03;
                
                ledGroup.add(led);
                leds.push(led);
            }

            ledGroup.userData.leds = leds;
        }

        // ========== RIBBON V√ÄNG ==========
        function createRibbons() {
            const positions = [];
            const colors = [];
            const sizes = [];

            for (let i = 0; i < 500; i++) {
                const t = i / 500;
                const angle = t * Math.PI * 2 * 10;
                const radius = BASE_RADIUS * (1 - t) * 0.88;
                
                const x = Math.cos(angle) * radius;
                const z = Math.sin(angle) * radius;
                const y = t * -TREE_HEIGHT + TREE_HEIGHT / 2;
                
                positions.push(x, y, z);
                colors.push(1, 0.84, 0); // Gold
                sizes.push(3 + Math.random() * 2);
            }

            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));

            const material = new THREE.PointsMaterial({
                size: 3.5,
                vertexColors: true,
                transparent: true,
                opacity: 0.95,
                blending: THREE.AdditiveBlending
            });

            const ribbon = new THREE.Points(geometry, material);
            treeGroup.add(ribbon);
        }

        // ========== TR√ÅI TIM ·ªû ƒê·ªàNH ==========
        function createHeartAtTop() {
            const heartPoints = 300;
            const topY = -TREE_HEIGHT / 2 + 50;
            const positions = [];
            const colors = [];
            const sizes = [];

            for (let i = 0; i < heartPoints; i++) {
                const t = (i / heartPoints) * Math.PI * 2;
                
                const hx = 16 * Math.pow(Math.sin(t), 3);
                const hy = -(13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t));
                
                const scale = 2;
                
                for (let j = 0; j < 2; j++) {
                    const hz = (Math.random() - 0.5) * 10;
                    positions.push(hx * scale, hy * scale + topY, hz * scale);
                    colors.push(1, 0.08, 0.58); // Hot pink
                    sizes.push(3 + Math.random() * 2);
                }
            }

            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));

            const material = new THREE.PointsMaterial({
                size: 3.5,
                vertexColors: true,
                transparent: true,
                opacity: 1,
                blending: THREE.AdditiveBlending
            });

            const heart = new THREE.Points(geometry, material);
            heart.userData.isPulsing = true;
            treeGroup.add(heart);
        }

        // ========== NG√îI SAO ·ªû ƒê·ªàNH ==========
        function createStarAtTop() {
            const starPoints = 5;
            const topY = -TREE_HEIGHT / 2;
            const outerRadius = 30;
            const innerRadius = 12;
            const positions = [];
            const colors = [];
            const sizes = [];

            for (let i = 0; i < starPoints * 2; i++) {
                const angle = (i / (starPoints * 2)) * Math.PI * 2 - Math.PI / 2;
                const radius = i % 2 === 0 ? outerRadius : innerRadius;
                
                for (let j = 0; j < 15; j++) {
                    const x = Math.cos(angle) * radius + (Math.random() - 0.5) * 2;
                    const z = Math.sin(angle) * radius + (Math.random() - 0.5) * 2;
                    const y = topY + (Math.random() - 0.5) * 4;
                    
                    positions.push(x, y, z);
                    colors.push(1, 1, 0);
                    sizes.push(4 + Math.random() * 3);
                }
            }

            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));

            const material = new THREE.PointsMaterial({
                size: 5,
                vertexColors: true,
                transparent: true,
                opacity: 1,
                blending: THREE.AdditiveBlending
            });

            const star = new THREE.Points(geometry, material);
            star.userData.isRotating = true;
            treeGroup.add(star);
        }

        // ========== H·ªòP QU√Ä ==========
        function createGiftBoxes() {
            const boxes = [
                {x: -90, z: 90, color: 0xff0000, size: 45},
                {x: 100, z: 80, color: 0x00ff00, size: 40},
                {x: -70, z: -100, color: 0x0000ff, size: 50},
                {x: 80, z: -90, color: 0xff00ff, size: 42}
            ];

            boxes.forEach(boxData => {
                // H·ªôp ch√≠nh
                const geometry = new THREE.BoxGeometry(boxData.size, boxData.size, boxData.size);
                const material = new THREE.MeshPhongMaterial({
                    color: boxData.color,
                    emissive: boxData.color,
                    emissiveIntensity: 0.4,
                    shininess: 100
                });
                
                const box = new THREE.Mesh(geometry, material);
                box.position.set(boxData.x, TREE_HEIGHT / 2 + boxData.size / 2 - 30, boxData.z);
                treeGroup.add(box);

                // N∆° v√†ng ngang
                const ribbonGeo1 = new THREE.BoxGeometry(boxData.size * 1.15, 6, 6);
                const ribbonMat = new THREE.MeshPhongMaterial({ 
                    color: 0xffd700,
                    emissive: 0xffd700,
                    emissiveIntensity: 0.3
                });
                const ribbon1 = new THREE.Mesh(ribbonGeo1, ribbonMat);
                ribbon1.position.copy(box.position);
                treeGroup.add(ribbon1);

                // N∆° v√†ng d·ªçc
                const ribbonGeo2 = new THREE.BoxGeometry(6, boxData.size * 1.15, 6);
                const ribbon2 = new THREE.Mesh(ribbonGeo2, ribbonMat);
                ribbon2.position.copy(box.position);
                treeGroup.add(ribbon2);

                // N∆° 3D ·ªü tr√™n
                const bowGeo = new THREE.SphereGeometry(8, 16, 16);
                const bow = new THREE.Mesh(bowGeo, ribbonMat);
                bow.position.set(boxData.x, TREE_HEIGHT / 2 + boxData.size - 20, boxData.z);
                bow.scale.set(1, 0.5, 1);
                treeGroup.add(bow);
            });
        }

        // ========== TUY·∫æT N·ªÄN ==========
        function createSnowFloor() {
            const positions = [];
            const colors = [];
            const sizes = [];

            for (let i = 0; i < 600; i++) {
                const angle = Math.random() * Math.PI * 2;
                const r = Math.random() * 600;
                const x = Math.cos(angle) * r;
                const z = Math.sin(angle) * r;
                const y = TREE_HEIGHT / 2 - 20;
                
                positions.push(x, y, z);
                
                const brightness = Math.random() > 0.7 ? 1 : 0.5;
                colors.push(brightness, brightness, brightness);
                sizes.push(2 + Math.random() * 3);
            }

            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));

            const material = new THREE.PointsMaterial({
                size: 2,
                vertexColors: true,
                transparent: true,
                opacity: 0.6
            });

            const floor = new THREE.Points(geometry, material);
            scene.add(floor);
        }

        // ========== TUY·∫æT R∆†I ==========
        function createSnowfall() {
            const snowCount = 150;
            const positions = [];
            const velocities = [];
            const sizes = [];

            for (let i = 0; i < snowCount; i++) {
                positions.push(
                    (Math.random() - 0.5) * 1000,
                    Math.random() * 800 - 200,
                    (Math.random() - 0.5) * 1000
                );
                velocities.push(
                    (Math.random() - 0.5) * 0.5,
                    -(1 + Math.random() * 2),
                    (Math.random() - 0.5) * 0.5
                );
                sizes.push(2 + Math.random() * 3);
            }

            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));

            const material = new THREE.PointsMaterial({
                size: 3,
                color: 0xffffff,
                transparent: true,
                opacity: 0.8,
                sizeAttenuation: true
            });

            const snow = new THREE.Points(geometry, material);
            snow.userData.velocities = velocities;
            snowGroup.add(snow);
        }

        // ========== PARTICLES PH√âP THU·∫¨T ==========
        function createMagicParticles() {
            const magicCount = 40;
            const positions = [];
            const colors = [];
            const sizes = [];
            const phases = [];

            for (let i = 0; i < magicCount; i++) {
                const angle = Math.random() * Math.PI * 2;
                const radius = 250 + Math.random() * 150;
                const height = (Math.random() - 0.5) * TREE_HEIGHT;
                
                const x = Math.cos(angle) * radius;
                const z = Math.sin(angle) * radius;
                
                positions.push(x, height, z);
                
                const color = new THREE.Color(COLORS[Math.floor(Math.random() * COLORS.length)]);
                colors.push(color.r, color.g, color.b);
                
                sizes.push(3 + Math.random() * 4);
                phases.push(Math.random() * Math.PI * 2);
            }

            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));

            const material = new THREE.PointsMaterial({
                size: 4,
                vertexColors: true,
                transparent: true,
                opacity: 0.7,
                blending: THREE.AdditiveBlending,
                sizeAttenuation: true
            });

            const magic = new THREE.Points(geometry, material);
            magic.userData.phases = phases;
            magic.userData.orbiting = true;
            magicGroup.add(magic);
        }

        // ========== √îNG GI√Ä NOEL V·ªöI H√åNH ·∫¢NH ==========
        function createSantaSleighImage() {
            const textureLoader = new THREE.TextureLoader();
            
            console.log('üîÑ Loading santa.jpg...');
            
            // Load h√¨nh ·∫£nh santa.jpg (ng∆∞·ªùi d√πng c·∫ßn ƒë·∫∑t file n√†y c√πng th∆∞ m·ª•c)
            textureLoader.load(
                'santa_v1.png',
                (texture) => {
                    console.log('‚úÖ Santa texture loaded!', texture.image.width + 'x' + texture.image.height);
                    
                    // T·∫°o sprite material v·ªõi hi·ªáu ·ª©ng chuy√™n nghi·ªáp
                    const spriteMaterial = new THREE.SpriteMaterial({
                        map: texture,
                        transparent: true,
                        opacity: 0.5, // Gi·∫£m opacity ƒë·ªÉ m·ªù h∆°n
                        blending: THREE.NormalBlending,
                        depthWrite: false,
                        fog: false
                    });
                    
                    santaSleighSprite = new THREE.Sprite(spriteMaterial);
                    
                    // K√≠ch th∆∞·ªõc sprite (ƒëi·ªÅu ch·ªânh theo t·ª∑ l·ªá h√¨nh ·∫£nh)
                    const scale = 200; // Thu nh·ªè k√≠ch th∆∞·ªõc
                    const aspectRatio = texture.image.width / texture.image.height;
                    santaSleighSprite.scale.set(scale * aspectRatio, scale, 1);
                    
                    console.log('üìè Sprite scale:', scale * aspectRatio, 'x', scale);
                    
                    // V·ªã tr√≠ b·∫Øt ƒë·∫ßu (b·∫Øt ƒë·∫ßu t·ª´ gi·ªØa m√†n h√¨nh ƒë·ªÉ test)
                    santaSleighSprite.position.set(-600, 100, 200); // Z=200 ƒë·ªÉ ·ªü tr∆∞·ªõc c√¢y
                    
                    // Th√¥ng tin animation
                    santaSleighSprite.userData.startX = -800;
                    santaSleighSprite.userData.endX = 800;
                    santaSleighSprite.userData.speed = 2.5; // T·ªëc ƒë·ªô bay
                    santaSleighSprite.userData.wave = 0;
                    
                    scene.add(santaSleighSprite);
                    
                    console.log('‚úÖ Santa sprite added to scene at position:', santaSleighSprite.position);
                    
                    // T·∫°o trail particles
                    createSleighTrail();
                },
                (progress) => {
                    console.log('‚è≥ Loading progress:', Math.round((progress.loaded / progress.total) * 100) + '%');
                },
                (error) => {
                    console.error('‚ùå Error loading santa.jpg:', error);
                    console.log('üí° H√£y ƒë·∫£m b·∫£o file santa.jpg n·∫±m c√πng th∆∞ m·ª•c v·ªõi file HTML');
                    console.log('üí° Ho·∫∑c th·ª≠ m·ªü file b·∫±ng local server: python3 -m http.server 8000');
                }
            );
        }
        
        function createSleighTrail() {
            const trailCount = 50;
            const positions = [];
            const colors = [];
            const sizes = [];
            const velocities = [];
            
            for (let i = 0; i < trailCount; i++) {
                positions.push(0, 0, 0);
                
                // M√†u v√†ng gold v·ªõi gradient
                const intensity = 1 - (i / trailCount) * 0.7;
                colors.push(1, intensity * 0.84, 0);
                sizes.push(8 - (i / trailCount) * 6);
                velocities.push(-(Math.random() * 2 + 1), (Math.random() - 0.5) * 0.5, 0);
            }
            
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));
            
            const material = new THREE.PointsMaterial({
                size: 8,
                vertexColors: true,
                transparent: true,
                opacity: 0.7,
                blending: THREE.AdditiveBlending,
                sizeAttenuation: true,
                depthWrite: false
            });
            
            sleighTrailParticles = new THREE.Points(geometry, material);
            sleighTrailParticles.userData.velocities = velocities;
            scene.add(sleighTrailParticles);
        }

        // ========== ANIMATION LOOP ==========
        let time = 0;

        function animate() {
            requestAnimationFrame(animate);
            time += 0.01;

            // Xoay c√¢y
            treeGroup.rotation.y += ROTATION_SPEED;

            // C·∫≠p nh·∫≠t LED nh·∫•p nh√°y
            if (ledGroup.userData.leds) {
                ledGroup.userData.leds.forEach(led => {
                    led.userData.blinkPhase += led.userData.blinkSpeed;
                    const brightness = (Math.sin(led.userData.blinkPhase) + 1) / 2;
                    led.material.emissiveIntensity = 0.3 + brightness * 0.7;
                    led.material.opacity = 0.5 + brightness * 0.5;
                });
            }

            // C·∫≠p nh·∫≠t tuy·∫øt r∆°i
            snowGroup.children.forEach(snow => {
                if (snow.userData.velocities) {
                    const positions = snow.geometry.attributes.position.array;
                    const velocities = snow.userData.velocities;

                    for (let i = 0; i < positions.length; i += 3) {
                        positions[i] += velocities[i];
                        positions[i + 1] += velocities[i + 1];
                        positions[i + 2] += velocities[i + 2];

                        // Reset n·∫øu r∆°i xu·ªëng qu√° th·∫•p
                        if (positions[i + 1] < -300) {
                            positions[i + 1] = 500;
                            positions[i] = (Math.random() - 0.5) * 1000;
                            positions[i + 2] = (Math.random() - 0.5) * 1000;
                        }
                    }

                    snow.geometry.attributes.position.needsUpdate = true;
                }
            });

            // C·∫≠p nh·∫≠t particles ph√©p thu·∫≠t (qu·ªπ ƒë·∫°o)
            magicGroup.children.forEach(magic => {
                if (magic.userData.orbiting) {
                    magic.rotation.y = time * 0.3;
                    
                    const positions = magic.geometry.attributes.position.array;
                    const phases = magic.userData.phases;

                    for (let i = 0; i < positions.length; i += 3) {
                        positions[i + 1] += Math.sin(time * 2 + phases[i / 3]) * 0.5;
                    }

                    magic.geometry.attributes.position.needsUpdate = true;
                }
            });

            // C·∫≠p nh·∫≠t Santa Sleigh Sprite (bay t·ª´ tr√°i sang ph·∫£i)
            if (santaSleighSprite) {
                // Di chuy·ªÉn t·ª´ tr√°i sang ph·∫£i
                santaSleighSprite.position.x += santaSleighSprite.userData.speed;
                
                // Hi·ªáu ·ª©ng l√™n xu·ªëng nh·∫π (sine wave)
                santaSleighSprite.userData.wave += 0.03;
                santaSleighSprite.position.y = Math.sin(santaSleighSprite.userData.wave) * 30;
                
                // Hi·ªáu ·ª©ng opacity (fade in/out)
                const distanceFromCenter = Math.abs(santaSleighSprite.position.x);
                const fadeDistance = 600;
                if (distanceFromCenter > fadeDistance) {
                    santaSleighSprite.material.opacity = Math.max(0, 0.85 - (distanceFromCenter - fadeDistance) / 200);
                } else {
                    santaSleighSprite.material.opacity = 0.85;
                }
                
                // Reset khi ra kh·ªèi m√†n h√¨nh ph·∫£i
                if (santaSleighSprite.position.x > santaSleighSprite.userData.endX) {
                    santaSleighSprite.position.x = santaSleighSprite.userData.startX;
                    santaSleighSprite.userData.wave = 0;
                }
                
                // C·∫≠p nh·∫≠t trail particles
                if (sleighTrailParticles) {
                    const positions = sleighTrailParticles.geometry.attributes.position.array;
                    const velocities = sleighTrailParticles.userData.velocities;
                    
                    for (let i = 0; i < positions.length; i += 3) {
                        // T·∫°o particles ph√≠a sau santa
                        if (i === 0) {
                            // Particle ƒë·∫ßu ti√™n lu√¥n ·ªü v·ªã tr√≠ santa
                            positions[i] = santaSleighSprite.position.x - 80;
                            positions[i + 1] = santaSleighSprite.position.y + (Math.random() - 0.5) * 30;
                            positions[i + 2] = santaSleighSprite.position.z;
                        } else {
                            // C√°c particles kh√°c di chuy·ªÉn v√† fade
                            positions[i] += velocities[i];
                            positions[i + 1] += velocities[i + 1];
                            
                            // Reset n·∫øu qu√° xa
                            if (positions[i] < santaSleighSprite.position.x - 300) {
                                positions[i] = santaSleighSprite.position.x - 80;
                                positions[i + 1] = santaSleighSprite.position.y + (Math.random() - 0.5) * 30;
                                positions[i + 2] = santaSleighSprite.position.z;
                            }
                        }
                    }
                    
                    sleighTrailParticles.geometry.attributes.position.needsUpdate = true;
                }
            }

            // Render
            renderer.render(scene, camera);
        }

        // ========== START ==========
        init();
        animate();

    </script>
</body>
</html>
